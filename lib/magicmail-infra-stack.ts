import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';

export class MagicmailInfraStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // --- Get context values ---
    // Use node.tryGetContext to safely retrieve context values
    const environment = this.node.tryGetContext('environment'); // Retrieves from cdk.json or CLI
    const project = this.node.tryGetContext('project');

    // Basic validation or default setting
    if (!environment || !project) {
      throw new Error("Context variables 'environment' and 'project' must be set in cdk.json or via --context");
    }

    // --- Define S3 Asset Bucket ---
    // This bucket stores assets like design files and mockups for MagicMail. <--- ADD THIS COMMENT
    const assetsBucket = new s3.Bucket(this, 'MagicMailAssetsBucket', {
      versioned: true,
      encryption: s3.BucketEncryption.S3_MANAGED,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
      // Use context value to determine Removal Policy
      removalPolicy: environment === 'prod' ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY,
      autoDeleteObjects: environment !== 'prod', // Enable auto-delete only for non-prod
      lifecycleRules: [/* ... */],
    });

    // --- Define DynamoDB Table for Creatures --- START ADDITION ---
    const creatureTable = new dynamodb.Table(this, 'CreatureDataTable', {
      // Define the primary key (partition key)
      partitionKey: {
        name: 'creatureId', // Name of the attribute
        type: dynamodb.AttributeType.STRING, // Type of the attribute
      },
      // Use Pay-Per-Request (On-Demand) billing
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      // Enable Point-in-Time Recovery (recommended for backups)
      pointInTimeRecoverySpecification: {
        pointInTimeRecoveryEnabled: true
      },
      // Set the removal policy - RETAIN is safer for data, DESTROY is easier for cleanup during dev/book
      // For the book, let's use DESTROY, but emphasize RETAIN for real data.
      removalPolicy: cdk.RemovalPolicy.DESTROY, // Use RETAIN for production data!
      // Table name will be dynamically generated by CloudFormation
    });
    // --- Define DynamoDB Table for Creatures --- END ADDITION ---

    // --- Add Tags ---
    cdk.Tags.of(assetsBucket).add('Project', project); // Use project context value
    cdk.Tags.of(assetsBucket).add('Environment', environment); // Use environment context value

    // --- Define Outputs ---
    // ... existing outputs ...
    // Modify export names to include environment for uniqueness if needed across environments
    new cdk.CfnOutput(this, 'AssetsBucketNameOutput', {
        value: assetsBucket.bucketName,
        description: `The name of the S3 bucket for ${environment} assets`,
        exportName: `${project}-${environment}-AssetsBucketName`, // More unique export name
    });
    new cdk.CfnOutput(this, 'AssetsBucketArnOutput', {
        value: assetsBucket.bucketArn,
        description: `The ARN of the S3 bucket for ${environment} assets`,
        exportName: `${project}-${environment}-AssetsBucketArn`,
    });
  }
}